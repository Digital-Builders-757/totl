# TOTL Agency - Cursor AI Assistant Rules

## 🎯 MANDATORY CONTEXT REFERENCE

**BEFORE WRITING ANY CODE, YOU MUST:**

1. **READ** `TOTL_PROJECT_CONTEXT_PROMPT.md` completely
2. **CHECK** `supabase/migrations/` for current database schema
3. **VERIFY** RLS policies in the context file
4. **USE** generated types from `types/database.ts` (NO `any` types)
5. **FOLLOW** established project structure and naming conventions

## 📋 PROJECT OVERVIEW

**TOTL Agency** - Talent booking platform connecting models/actors with casting directors/brands

**Tech Stack:**
- Next.js 15.2.4 + App Router + TypeScript 5
- Supabase (PostgreSQL + Auth + Storage + Real-time)
- TailwindCSS + shadcn/ui components
- Resend API for custom emails

**Database:** PostgreSQL with RLS policies on all tables
**Auth:** Supabase Auth with role-based access (talent/client/admin)
**Key Tables:** profiles, talent_profiles, client_profiles, gigs, applications, bookings, portfolio_items

## 📋 PROJECT CONTEXT SUMMARY

**Tech Stack:** Next.js 15.2.4 + Supabase + TypeScript + shadcn/ui
**Database:** PostgreSQL with RLS policies on all tables
**Auth:** Supabase Auth with role-based access (talent/client/admin)
**Key Tables:** profiles, talent_profiles, client_profiles, gigs, applications, bookings, portfolio_items
**Security:** Row-level security enforced, no service keys in client code
**Architecture:** Server components for data fetching, presentational components only

## ✅ COMPLIANCE CHECKLIST

Before generating any code, ensure:
- [ ] Referenced `TOTL_PROJECT_CONTEXT_PROMPT.md` for complete context
- [ ] **🚨 CRITICAL: database_schema_audit.md is the SINGLE SOURCE OF TRUTH**
- [ ] Used proper TypeScript types (no `any`)
- [ ] Followed RLS-compatible query patterns
- [ ] Separated database logic from React components
- [ ] Used centralized Supabase clients (`lib/supabase-client.ts`)
- [ ] Implemented proper error handling
- [ ] Followed project naming conventions

## 🏗️ ARCHITECTURE RULES

### Database Access
- Use `lib/supabase-client.ts` for client-side queries
- Use `lib/supabase-admin-client.ts` for server-side admin operations
- Always assume RLS is active - never bypass security policies
- Use generated types from `types/database.ts`

### Component Structure
- React components should be presentational only
- No direct database calls in components
- Use server components for data fetching
- Pass data as props to client components

### Authentication & Authorization
- **🚨 BEFORE ANY AUTH CHANGES:** Read `docs/AUTH_DATABASE_TRIGGER_CHECKLIST.md`
- Use `@supabase/auth-helpers-nextjs` for session management
- Check user roles before allowing actions
- Use middleware for route protection
- Implement proper error handling for auth failures
- **CRITICAL:** Verify database triggers match `database_schema_audit.md` schema

### Security Best Practices
- Never expose service keys in client code
- Always validate user permissions before data access
- Use parameterized queries (Supabase handles this)
- Follow least privilege principle

## 🚫 FORBIDDEN PATTERNS

- Using `any` types in TypeScript
- **🚨 Making database changes without updating `database_schema_audit.md`**
- **🚨 Updating `types/database.ts` without referencing the audit file**
- Direct database calls in React components
- Bypassing RLS policies
- Exposing service keys to client
- Mixing database logic with UI logic
- Using raw SQL instead of Supabase query builder

## 📁 CRITICAL FILES TO REFERENCE

- `TOTL_PROJECT_CONTEXT_PROMPT.md` - Complete project context
- **🚨 `database_schema_audit.md` - SINGLE SOURCE OF TRUTH for database schema**
- **🚨 `docs/AUTH_DATABASE_TRIGGER_CHECKLIST.md` - MANDATORY before auth changes**
- `types/database.ts` - Generated Supabase types
- `supabase/migrations/` - Database schema history
- `lib/supabase-client.ts` - Client configuration
- `middleware.ts` - Route protection logic
- `components/auth/auth-provider.tsx` - Authentication context (correct path)

## 🔄 WHEN TO APPLY

This rule applies to:
- All code generation for this project
- Database schema changes or migrations
- New feature development
- Bug fixes or refactoring
- API route creation or modification
- Component creation or updates

---

**Remember: Always reference the full context file before writing any code. This ensures consistency, security, and proper architecture compliance.** 

## Database Types & Codegen
- `types/database.ts` is auto-generated from Supabase. Do not hand-edit.
- After any SQL/migration changes, run:
  `npx supabase gen types typescript --project-id "$SUPABASE_PROJECT_ID" --schema public > types/database.ts`
- Prepend an AUTO-GENERATED banner to discourage edits.

## Supabase Client
- Use a single typed client from `lib/supabase-client.ts`.
- Do not import `@supabase/supabase-js` directly in pages/components.

## Query Style
- Default: explicit column selection. Avoid `select('*')` in app code.
- Exception: internal admin scripts in `scripts/` may use `*`.

## Security
- No service role in client/browser code. Server-only (API routes, server actions).

## Component Boundaries
- Presentational components: no data fetching.
- Server components/actions do all data I/O and pass typed props.

**Schema Management**  
- **Single Source of Truth:** Always update the `database_schema_audit.md` **before** making any database schema changes. This audit file represents the ground truth of the database schema. Never apply a migration or change the database without first reflecting the change in this file.  
- **Migrations Required:** All schema modifications must be done via version-controlled Supabase migration files (in `supabase/migrations`). Never edit the database schema manually without a migration. Update the audit file and then generate a new migration file using the Supabase CLI.  
- **Generated Types Only:** After any schema change, **regenerate** the TypeScript types using the Supabase CLI (`supabase gen types typescript`). The file `types/database.ts` must always be generated from the live schema – do not manually edit this file.  
- **No Drift:** The schema defined in `database_schema_audit.md`, the database itself, and `types/database.ts` should always be in sync. Use automated checks (scripts/CI) to verify that the audit file and the types file accurately reflect the actual database.  

**Type Safety**  
- **Use Generated Types:** The **only** source of TypeScript types for database entities is `types/database.ts`. Do not declare separate interfaces or types in components or elsewhere for tables like Profile, Gig, Application, etc. Instead, import and use the types from the generated file. This prevents duplicate definitions drifting from the truth.  
- **No `any` for DB Data:** Do not use `any` types when handling database results or writing queries. All data must be strongly typed according to the generated types. If a query result is not properly typed, refine the query or the types rather than resorting to `any`.  
- **Enum Consistency:** Whenever you update a database enum (for example, adding a new status), update the enum values in `database_schema_audit.md` and regenerate the types file. Ensure that any code using these enum values (strings or union types) is updated to match.  

**Database Access Pattern**  
- **Centralized Client:** All database calls must go through the single Supabase client instances provided (`lib/supabase-client.ts` for user-level access and `lib/supabase-admin-client.ts` for admin tasks). **Do not** instantiate new Supabase clients or use the Supabase JS library directly in components or API routes. This ensures that Row-Level Security (RLS) policies are consistently applied and that the types are correctly utilized.  
- **Secure by Default:** RLS policies are in effect on all tables. Query the database in a role-appropriate way (e.g., using the anon/user client for user operations which will enforce RLS). Only use the admin client (service role) in server-side code that is trusted and needs to bypass RLS (such as internal tools or admin functionality).  
- **No Logic in Components:** Keep database logic out of React components. React components (especially UI and pages) should call functions in the `lib/` layer (or Next.js Server Actions) which contain the actual database queries. This separation ensures easier maintenance and consistent enforcement of types and security.  

**Verification**  
- **Pre-commit Checks:** Always run the schema verification script (`scripts/verify-schema-sync.ps1`) before committing or opening a PR. This script will flag any type mismatches, outdated schema documentation, usage of `any`, or local interface duplications. Fix any issues it reports.  
- **CI Enforcement:** The CI pipeline will block any pull request that introduces schema drift or type inconsistencies. If the CI fails due to the schema truth checks, regenerate the types, update the audit documentation, or remove any forbidden patterns as indicated, then commit the fixes.  

**PowerShell Environment**
- **Use PowerShell Commands:** Always use PowerShell-compatible commands in this Windows environment
- **File Operations:** Use `Get-ChildItem` instead of `ls`, `Get-Content` instead of `cat`, `Select-String` instead of `grep`
- **Scripts:** All verification and automation scripts should be PowerShell-compatible

**Documentation-First Approach**
- **Check Documentation FIRST:** Before making ANY changes, check `docs/DOCUMENTATION_INDEX.md` to find relevant documentation for the area you're working on
- **Read Relevant Docs:** Read all applicable documentation files for the feature/component you're modifying
- **Common Documentation to Check:**
  - Authentication work → Read `docs/AUTH_STRATEGY.md`
  - Security changes → Read `docs/SECURITY_CONFIGURATION.md`
  - Database changes → Read `database_schema_audit.md` (root) and `docs/DATABASE_REPORT.md`
  - Admin features → Read `docs/ADMIN_ACCOUNT_GUIDE.md`
  - Feature implementation → Check `docs/` for related implementation guides
  - Bug fixes → Check `docs/TROUBLESHOOTING_GUIDE.md`
- **Update Documentation:** Always update relevant documentation after significant changes
- **Reference Audit File:** Always reference `database_schema_audit.md` for database schema truth
- **Maintain Consistency:** Ensure all documentation reflects the current state of the project

## 📚 MANDATORY DOCUMENTATION CHECK WORKFLOW

**BEFORE starting ANY work:**
1. Check `docs/DOCUMENTATION_INDEX.md` to identify relevant documentation
2. Read ALL relevant docs for the area you're working on
3. Verify your approach aligns with documented patterns
4. Only then proceed with implementation

**AFTER completing work:**
1. Update any relevant documentation
2. Add new documentation if you created a significant feature
3. Update `docs/DOCUMENTATION_INDEX.md` if you added new docs

## 📝 DOCUMENTATION CREATION RULES

**ALL new documentation files MUST be created in the `docs/` folder, NOT the root directory.**

**Exceptions (ONLY these files belong in root):**
- `README.md` - Project overview
- `database_schema_audit.md` - Database schema single source of truth
- `MVP_STATUS_NOTION.md` - MVP tracking (update before commits)
- `notion_update.md` - Notion update tracking

**Everything else goes in `docs/`:**
- ✅ Feature implementation guides → `docs/`
- ✅ Bug fix summaries → `docs/`
- ✅ Setup guides → `docs/`
- ✅ Troubleshooting docs → `docs/`
- ✅ Security documentation → `docs/`
- ✅ Any other documentation → `docs/`

**When creating new documentation:**
1. Always create files in `docs/` folder
2. Use clear, descriptive filenames (ALL_CAPS_WITH_UNDERSCORES.md or lowercase-with-hyphens.md)
3. Update `docs/DOCUMENTATION_INDEX.md` to include the new file
4. Add appropriate category tags and cross-references 