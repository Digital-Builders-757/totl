# TOTL Agency - Cursor AI Assistant Rules

## üéØ MANDATORY CONTEXT REFERENCE

**BEFORE WRITING ANY CODE, YOU MUST:**

1. **READ** `AGENT_ONBOARDING.md` for quick start guide (NEW AGENTS START HERE)
2. **READ** `TOTL_PROJECT_CONTEXT_PROMPT.md` completely
3. **CHECK** `supabase/migrations/` for current database schema
4. **VERIFY** RLS policies in the context file
5. **USE** generated types from `types/database.ts` (NO `any` types)
6. **FOLLOW** established project structure and naming conventions

## üìã PROJECT OVERVIEW

**TOTL Agency** - Talent booking platform connecting models/actors with casting directors/brands

**Tech Stack:**
- Next.js 15.2.4 + App Router + TypeScript 5
- Supabase (PostgreSQL + Auth + Storage + Real-time)
- TailwindCSS + shadcn/ui components
- Resend API for custom emails

**Database:** PostgreSQL with RLS policies on all tables
**Auth:** Supabase Auth with role-based access (talent/client/admin)
**Key Tables:** profiles, talent_profiles, client_profiles, gigs, applications, bookings, portfolio_items

## üìã PROJECT CONTEXT SUMMARY

**Tech Stack:** Next.js 15.2.4 + Supabase + TypeScript + shadcn/ui
**Database:** PostgreSQL with RLS policies on all tables
**Auth:** Supabase Auth with role-based access (talent/client/admin)
**Key Tables:** profiles, talent_profiles, client_profiles, gigs, applications, bookings, portfolio_items
**Security:** Row-level security enforced, no service keys in client code
**Architecture:** Server components for data fetching, presentational components only

## ‚úÖ COMPLIANCE CHECKLIST

Before generating any code, ensure:
- [ ] Referenced `TOTL_PROJECT_CONTEXT_PROMPT.md` for complete context
- [ ] **üö® CRITICAL: database_schema_audit.md is the SINGLE SOURCE OF TRUTH**
- [ ] Used proper TypeScript types (no `any`)
- [ ] Followed RLS-compatible query patterns
- [ ] Separated database logic from React components
- [ ] Used centralized Supabase clients (`lib/supabase-client.ts`)
- [ ] Implemented proper error handling
- [ ] Followed project naming conventions

## üèóÔ∏è ARCHITECTURE RULES

### Database Access
- Use `lib/supabase-client.ts` for client-side queries
- Use `lib/supabase-admin-client.ts` for server-side admin operations
- Always assume RLS is active - never bypass security policies
- Use generated types from `types/database.ts`

### Component Structure
- React components should be presentational only
- No direct database calls in components
- Use server components for data fetching
- Pass data as props to client components

### Authentication & Authorization
- **üö® BEFORE ANY AUTH CHANGES:** Read `docs/AUTH_DATABASE_TRIGGER_CHECKLIST.md`
- Use `@supabase/auth-helpers-nextjs` for session management
- Check user roles before allowing actions
- Use middleware for route protection
- Implement proper error handling for auth failures
- **CRITICAL:** Verify database triggers match `database_schema_audit.md` schema

### Security Best Practices
- Never expose service keys in client code
- Always validate user permissions before data access
- Use parameterized queries (Supabase handles this)
- Follow least privilege principle

## üö´ FORBIDDEN PATTERNS

- Using `any` types in TypeScript
- **üö® Making database changes without updating `database_schema_audit.md`**
- **üö® Updating `types/database.ts` without referencing the audit file**
- Direct database calls in React components
- Bypassing RLS policies
- Exposing service keys to client
- Mixing database logic with UI logic
- Using raw SQL instead of Supabase query builder

## üìÅ CRITICAL FILES TO REFERENCE

- `TOTL_PROJECT_CONTEXT_PROMPT.md` - Complete project context
- **üö® `database_schema_audit.md` - SINGLE SOURCE OF TRUTH for database schema**
- **üö® `docs/AUTH_DATABASE_TRIGGER_CHECKLIST.md` - MANDATORY before auth changes**
- `types/database.ts` - Generated Supabase types
- `supabase/migrations/` - Database schema history
- `lib/supabase-client.ts` - Client configuration
- `middleware.ts` - Route protection logic
- `components/auth/auth-provider.tsx` - Authentication context (correct path)

## üîÑ WHEN TO APPLY

This rule applies to:
- All code generation for this project
- Database schema changes or migrations
- New feature development
- Bug fixes or refactoring
- API route creation or modification
- Component creation or updates

---

**Remember: Always reference the full context file before writing any code. This ensures consistency, security, and proper architecture compliance.** 

## Database Types & Codegen
- `types/database.ts` is auto-generated from Supabase. Do not hand-edit.
- After any SQL/migration changes, run:
  `npx supabase gen types typescript --project-id "$SUPABASE_PROJECT_ID" --schema public > types/database.ts`
- Prepend an AUTO-GENERATED banner to discourage edits.

## Supabase Client
- Use a single typed client from `lib/supabase-client.ts`.
- Do not import `@supabase/supabase-js` directly in pages/components.

## Query Style
- Default: explicit column selection. Avoid `select('*')` in app code.
- Exception: internal admin scripts in `scripts/` may use `*`.

## Security
- No service role in client/browser code. Server-only (API routes, server actions).

## Component Boundaries
- Presentational components: no data fetching.
- Server components/actions do all data I/O and pass typed props.

**Schema Management**  
- **Single Source of Truth:** Always update the `database_schema_audit.md` **before** making any database schema changes. This audit file represents the ground truth of the database schema. Never apply a migration or change the database without first reflecting the change in this file.  
- **Migrations Required:** All schema modifications must be done via version-controlled Supabase migration files (in `supabase/migrations`). Never edit the database schema manually without a migration. Update the audit file and then generate a new migration file using the Supabase CLI.  
- **Generated Types Only:** After any schema change, **regenerate** the TypeScript types using the Supabase CLI (`supabase gen types typescript`). The file `types/database.ts` must always be generated from the live schema ‚Äì do not manually edit this file.  
- **No Drift:** The schema defined in `database_schema_audit.md`, the database itself, and `types/database.ts` should always be in sync. Use automated checks (scripts/CI) to verify that the audit file and the types file accurately reflect the actual database.  

**Type Safety**  
- **Use Generated Types:** The **only** source of TypeScript types for database entities is `types/database.ts`. Do not declare separate interfaces or types in components or elsewhere for tables like Profile, Gig, Application, etc. Instead, import and use the types from the generated file. This prevents duplicate definitions drifting from the truth.  
- **No `any` for DB Data:** Do not use `any` types when handling database results or writing queries. All data must be strongly typed according to the generated types. If a query result is not properly typed, refine the query or the types rather than resorting to `any`.  
- **Enum Consistency:** Whenever you update a database enum (for example, adding a new status), update the enum values in `database_schema_audit.md` and regenerate the types file. Ensure that any code using these enum values (strings or union types) is updated to match.  

**Database Access Pattern**  
- **Centralized Client:** All database calls must go through the single Supabase client instances provided (`lib/supabase-client.ts` for user-level access and `lib/supabase-admin-client.ts` for admin tasks). **Do not** instantiate new Supabase clients or use the Supabase JS library directly in components or API routes. This ensures that Row-Level Security (RLS) policies are consistently applied and that the types are correctly utilized.  
- **Secure by Default:** RLS policies are in effect on all tables. Query the database in a role-appropriate way (e.g., using the anon/user client for user operations which will enforce RLS). Only use the admin client (service role) in server-side code that is trusted and needs to bypass RLS (such as internal tools or admin functionality).  
- **No Logic in Components:** Keep database logic out of React components. React components (especially UI and pages) should call functions in the `lib/` layer (or Next.js Server Actions) which contain the actual database queries. This separation ensures easier maintenance and consistent enforcement of types and security.  

**Verification**  
- **Pre-commit Checks:** Always run the schema verification script (`scripts/verify-schema-sync.ps1`) before committing or opening a PR. This script will flag any type mismatches, outdated schema documentation, usage of `any`, or local interface duplications. Fix any issues it reports.  
- **CI Enforcement:** The CI pipeline will block any pull request that introduces schema drift or type inconsistencies. If the CI fails due to the schema truth checks, regenerate the types, update the audit documentation, or remove any forbidden patterns as indicated, then commit the fixes.  

**PowerShell Environment**
- **Use PowerShell Commands:** Always use PowerShell-compatible commands in this Windows environment
- **File Operations:** Use `Get-ChildItem` instead of `ls`, `Get-Content` instead of `cat`, `Select-String` instead of `grep`
- **Scripts:** All verification and automation scripts should be PowerShell-compatible

**Documentation-First Approach**
- **Check Documentation FIRST:** Before making ANY changes, check `docs/DOCUMENTATION_INDEX.md` to find relevant documentation for the area you're working on
- **Read Relevant Docs:** Read all applicable documentation files for the feature/component you're modifying
- **Common Documentation to Check:**
  - Authentication work ‚Üí Read `docs/AUTH_STRATEGY.md`
  - Security changes ‚Üí Read `docs/SECURITY_CONFIGURATION.md`
  - Database changes ‚Üí Read `database_schema_audit.md` (root) and `docs/DATABASE_REPORT.md`
  - Admin features ‚Üí Read `docs/ADMIN_ACCOUNT_GUIDE.md`
  - Feature implementation ‚Üí Check `docs/` for related implementation guides
  - Bug fixes ‚Üí Check `docs/TROUBLESHOOTING_GUIDE.md`
- **Update Documentation:** Always update relevant documentation after significant changes
- **Reference Audit File:** Always reference `database_schema_audit.md` for database schema truth
- **Maintain Consistency:** Ensure all documentation reflects the current state of the project

## üìö MANDATORY DOCUMENTATION CHECK WORKFLOW

**BEFORE starting ANY work:**
1. Check `docs/DOCUMENTATION_INDEX.md` to identify relevant documentation
2. Read ALL relevant docs for the area you're working on
3. Verify your approach aligns with documented patterns
4. Only then proceed with implementation

**AFTER completing work:**
1. Update any relevant documentation
2. Add new documentation if you created a significant feature
3. Update `docs/DOCUMENTATION_INDEX.md` if you added new docs

## üìù DOCUMENTATION CREATION RULES

**ALL new documentation files MUST be created in the `docs/` folder, NOT the root directory.**

**Exceptions (ONLY these files belong in root):**
- `README.md` - Project overview
- `database_schema_audit.md` - Database schema single source of truth
- `MVP_STATUS_NOTION.md` - MVP tracking (update before commits)
- `notion_update.md` - Notion update tracking

**Everything else goes in `docs/`:**
- ‚úÖ Feature implementation guides ‚Üí `docs/`
- ‚úÖ Bug fix summaries ‚Üí `docs/`
- ‚úÖ Setup guides ‚Üí `docs/`
- ‚úÖ Troubleshooting docs ‚Üí `docs/`
- ‚úÖ Security documentation ‚Üí `docs/`
- ‚úÖ Any other documentation ‚Üí `docs/`

**When creating new documentation:**
1. Always create files in `docs/` folder
2. Use clear, descriptive filenames (ALL_CAPS_WITH_UNDERSCORES.md or lowercase-with-hyphens.md)
3. Update `docs/DOCUMENTATION_INDEX.md` to include the new file
4. Add appropriate category tags and cross-references

## üö® CRITICAL ERROR PREVENTION - MANDATORY CHECKS

**BEFORE PUSHING ANY CODE TO DEVELOP OR MAIN, YOU MUST:**

### **1. SCHEMA & TYPES VERIFICATION**
```bash
# ALWAYS run these commands before pushing
npm run schema:verify:comprehensive
npm run types:check
npm run build
```

### **2. IMPORT PATH VERIFICATION**
**‚ùå NEVER USE THESE INCORRECT PATHS:**
- `@/lib/supabase/supabase-admin-client` (WRONG - extra `/supabase/`)
- `@/types/database` (WRONG - should be `/types/supabase`)

**‚úÖ ALWAYS USE THESE CORRECT PATHS:**
- `@/lib/supabase-admin-client` (CORRECT)
- `@/types/supabase` (CORRECT)

### **3. COMMON ERRORS TO AVOID**
- **Schema Sync Errors:** `types/database.ts is out of sync with remote schema`
  - **Fix:** Run `npm run types:regen` for correct environment
- **Import Path Errors:** `Module not found: Can't resolve '@/lib/supabase/supabase-admin-client'`
  - **Fix:** Use correct path `@/lib/supabase-admin-client`
- **Type Errors:** `Property 'role' does not exist on type 'never'`
  - **Fix:** Ensure Database type is imported from `@/types/supabase`
- **Build Failures:** Any build that doesn't pass locally
  - **Fix:** Never push code that doesn't build locally

### **4. BRANCH-SPECIFIC REQUIREMENTS**
- **DEVELOP Branch:** Use `npm run types:regen:dev` if needed
- **MAIN Branch:** Use `npm run types:regen:prod` if needed
- **Both Branches:** Must pass `npm run build` before pushing

### **5. EMERGENCY FIXES**
If you encounter these errors:
```bash
# Schema sync error
npm run types:regen && npm run build

# Import path errors - find and fix manually
grep -r "@/lib/supabase/supabase-admin-client" . --exclude-dir=node_modules

# Build failures - fix locally first
npm run build
```

**üö® CRITICAL RULE: NEVER PUSH CODE THAT DOESN'T BUILD LOCALLY!**

## üìã PRE-PUSH CHECKLIST REFERENCE

**ALWAYS run this checklist before pushing:**
1. ‚úÖ `npm run schema:verify:comprehensive`
2. ‚úÖ `npm run build`
3. ‚úÖ `npm run lint`
4. ‚úÖ Check import paths are correct
5. ‚úÖ Verify branch-specific types are generated
6. ‚úÖ Read `docs/PRE_PUSH_CHECKLIST.md` for detailed guidance

**If ANY step fails, DO NOT PUSH until it's fixed!**

---

## üíª CODE STYLE & STRUCTURE GUIDELINES

### TypeScript Code Style

**General Principles:**
- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`, `canEdit`)
- Structure files: exported component ‚Üí subcomponents ‚Üí helpers ‚Üí static content ‚Üí types

**TypeScript Usage:**
- Use TypeScript for all code; prefer `interface` over `type` for object shapes
- Avoid enums; use const objects with `as const` or union types instead
- Use functional components with TypeScript interfaces for props
- Always use strict TypeScript mode (already configured)
- Import types with `import type` when importing only types

**Example:**
```typescript
// ‚úÖ GOOD - Interface for props
interface ButtonProps {
  isLoading?: boolean;
  hasError?: boolean;
  onClick: () => void;
}

// ‚úÖ GOOD - Const object instead of enum
const Status = {
  ACTIVE: "active",
  INACTIVE: "inactive",
  PENDING: "pending",
} as const;

type Status = typeof Status[keyof typeof Status];

// ‚ùå BAD - Avoid enums
enum Status {
  ACTIVE = "active",
  INACTIVE = "inactive",
}
```

### Naming Conventions

**Files & Directories:**
- Use **kebab-case** for all file and directory names
  - ‚úÖ `talent-signup-form.tsx`
  - ‚úÖ `apply-as-talent-button.tsx`
  - ‚úÖ `components/auth/`
  - ‚úÖ `components/forms/`
  - ‚ùå `TalentSignupForm.tsx` (PascalCase)
  - ‚ùå `applyAsTalentButton.tsx` (camelCase)

**Components:**
- Use **PascalCase** for component names
- Prefer **named exports** for components (default exports acceptable for pages)
- Use descriptive, component-specific names

**Example:**
```typescript
// ‚úÖ GOOD - Named export
export function TalentSignupForm({ ... }: TalentSignupFormProps) {
  // ...
}

// ‚úÖ GOOD - Default export for pages
export default function TalentDashboard() {
  // ...
}

// ‚úÖ GOOD - Component-specific interface
interface TalentSignupFormProps {
  onComplete?: () => void;
}
```

**Variables & Functions:**
- Use **camelCase** for variables and functions
- Use descriptive names with auxiliary verbs for booleans (`is`, `has`, `can`, `should`)
- Use verb-noun pattern for functions (`getUser`, `createGig`, `updateProfile`)

**Example:**
```typescript
// ‚úÖ GOOD
const isLoading = true;
const hasError = false;
const canEdit = user.role === "admin";
const userCount = users.length;

function getUserById(id: string) { ... }
function createGig(data: GigData) { ... }
```

### Syntax and Formatting

**Function Declarations:**
- Use the `function` keyword for pure functions and components
- Use arrow functions for callbacks, inline functions, and short utilities
- Prefer concise syntax for simple conditionals (avoid unnecessary braces)

**Example:**
```typescript
// ‚úÖ GOOD - Function keyword for components
export function Button({ children }: ButtonProps) {
  return <button>{children}</button>;
}

// ‚úÖ GOOD - Arrow function for callbacks
const handleClick = () => {
  // ...
};

// ‚úÖ GOOD - Concise conditional
if (isLoading) return <Spinner />;
if (hasError) return <Error />;

// ‚ùå BAD - Unnecessary braces
if (isLoading) {
  return <Spinner />;
}
```

**JSX & Declarative Code:**
- Use declarative JSX patterns
- Prefer composition over complex conditional rendering
- Extract complex logic into helper functions or custom hooks

**Example:**
```typescript
// ‚úÖ GOOD - Declarative
return (
  <div>
    {isLoading && <Spinner />}
    {!isLoading && data && <DataDisplay data={data} />}
    {error && <ErrorMessage error={error} />}
  </div>
);

// ‚úÖ BETTER - Extract complex logic
function renderContent() {
  if (isLoading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  return <DataDisplay data={data} />;
}

return <div>{renderContent()}</div>;
```

### Component Structure

**File Organization:**
1. Imports (external ‚Üí internal ‚Üí types)
2. Type definitions (interfaces, types)
3. Constants and helpers
4. Main component
5. Subcomponents (if any)
6. Exports

**Example Structure:**
```typescript
// 1. Imports
import { useState } from "react";
import { Button } from "@/components/ui/button";
import type { Database } from "@/types/supabase";

// 2. Types
interface ComponentProps {
  userId: string;
}

// 3. Constants
const MAX_RETRIES = 3;

// 4. Helpers
function formatDate(date: Date) {
  // ...
}

// 5. Main Component
export function Component({ userId }: ComponentProps) {
  // ...
}

// 6. Subcomponents (if any)
function SubComponent() {
  // ...
}
```

### UI and Styling

**Component Libraries:**
- Use **shadcn/ui** components as the primary UI library
- Use **Radix UI** primitives (via shadcn/ui) for accessibility
- Use **TailwindCSS** for all styling (no CSS modules or styled-components)

**Responsive Design:**
- Implement responsive design with TailwindCSS
- Use **mobile-first approach** (base styles for mobile, then `md:`, `lg:`, `xl:` breakpoints)
- Test on multiple screen sizes

**Example:**
```typescript
// ‚úÖ GOOD - Mobile-first Tailwind
<div className="flex flex-col gap-4 md:flex-row md:gap-8 lg:gap-12">
  <div className="w-full md:w-1/2 lg:w-1/3">...</div>
</div>
```

**Image Optimization:**
- Use Next.js `Image` component or project's `SafeImage` component
- Prefer WebP format when possible
- Include size data (`width`, `height`, or `fill`)
- Implement lazy loading for below-the-fold images

**Example:**
```typescript
// ‚úÖ GOOD - Using SafeImage component
import { SafeImage } from "@/components/ui/safe-image";

<SafeImage
  src={imageUrl}
  alt="Description"
  width={800}
  height={600}
  className="rounded-lg"
/>
```

### Performance Optimization

**React Server Components (RSC):**
- **Minimize `"use client"`** - Default to Server Components
- Use Server Components for:
  - Data fetching (Supabase queries)
  - Server-side logic
  - Environment variable access
  - SEO-critical content
- Use Client Components only for:
  - Browser APIs (`window`, `localStorage`, etc.)
  - Event handlers (`onClick`, `onChange`)
  - React hooks (`useState`, `useEffect`, `useContext`)
  - Third-party client-only libraries

**Example:**
```typescript
// ‚úÖ GOOD - Server Component (default)
export default async function GigsPage() {
  const supabase = await createSupabaseServer();
  const { data } = await supabase.from("gigs").select("*");
  
  return <GigsList gigs={data} />;
}

// ‚úÖ GOOD - Client Component (only when needed)
"use client";

export function GigsList({ gigs }: { gigs: Gig[] }) {
  const [filter, setFilter] = useState("");
  
  return (
    <div>
      <input onChange={(e) => setFilter(e.target.value)} />
      {/* ... */}
    </div>
  );
}
```

**Hooks & State Management:**
- Minimize `useEffect` and `useState` usage
- Prefer Server Components and Server Actions for data mutations
- Use `useEffect` only for:
  - Browser API interactions
  - Subscriptions (Supabase real-time)
  - Side effects that can't be handled server-side

**Suspense & Loading States:**
- Wrap client components in `Suspense` with fallback
- Use loading.tsx files for route-level loading states
- Provide meaningful loading indicators

**Example:**
```typescript
// ‚úÖ GOOD - Suspense boundary
<Suspense fallback={<LoadingSpinner />}>
  <AsyncComponent />
</Suspense>
```

**Dynamic Loading:**
- Use `next/dynamic` for non-critical components
- Lazy load heavy components (charts, editors, etc.)
- Use `ssr: false` for client-only components

**Example:**
```typescript
// ‚úÖ GOOD - Dynamic import for heavy component
import dynamic from "next/dynamic";

const HeavyChart = dynamic(() => import("./heavy-chart"), {
  loading: () => <ChartSkeleton />,
  ssr: false,
});
```

### URL Search Parameters

**Next.js App Router Pattern:**
- Use Next.js `searchParams` prop for Server Components
- Use `useSearchParams()` hook for Client Components (with SSR safety)
- Always use optional chaining (`?.`) and nullish coalescing (`??`) for safety
- See `docs/USESEARCHPARAMS_SSR_GUIDE.md` for detailed patterns

**Example:**
```typescript
// ‚úÖ GOOD - Server Component
export default async function Page({
  searchParams,
}: {
  searchParams: Promise<Record<string, string | string[] | undefined>>;
}) {
  const params = await searchParams;
  const category = typeof params.category === "string" ? params.category : "all";
  
  return <GigsList category={category} />;
}

// ‚úÖ GOOD - Client Component (safe SSR pattern)
"use client";

export function FilterComponent() {
  const searchParams = useSearchParams();
  const [category, setCategory] = useState("all");
  
  useEffect(() => {
    const categoryParam = searchParams?.get("category") ?? "all";
    setCategory(categoryParam);
  }, [searchParams]);
  
  return <div>Category: {category}</div>;
}
```

### Web Vitals Optimization

**Core Web Vitals:**
- **LCP (Largest Contentful Paint):** Optimize images, use `priority` prop for above-the-fold images
- **CLS (Cumulative Layout Shift):** Set explicit dimensions for images and containers
- **FID (First Input Delay):** Minimize JavaScript, use code splitting, defer non-critical scripts

**Example:**
```typescript
// ‚úÖ GOOD - Optimized image with priority
<SafeImage
  src={heroImage}
  alt="Hero"
  width={1920}
  height={1080}
  priority
  className="w-full h-auto"
/>
```

### Code Quality Standards

**Error Handling:**
- Always wrap async operations in try-catch blocks
- Provide meaningful error messages
- Use project's error logging utilities (`lib/error-logger.ts`)
- Handle Supabase errors gracefully

**Example:**
```typescript
// ‚úÖ GOOD - Proper error handling
async function fetchGig(id: string) {
  try {
    const { data, error } = await supabase
      .from("gigs")
      .select("*")
      .eq("id", id)
      .single();
    
    if (error) throw error;
    return data;
  } catch (error) {
    console.error("Failed to fetch gig:", error);
    throw error;
  }
}
```

**Code Comments:**
- Write self-documenting code (prefer clear names over comments)
- Add comments for complex business logic or non-obvious decisions
- Use JSDoc for public APIs and utilities

**Accessibility:**
- Use semantic HTML elements
- Include proper ARIA labels where needed
- Ensure keyboard navigation works
- Test with screen readers (Radix UI components handle this)

---

**Remember:** These style guidelines complement the existing architecture and security rules. Always prioritize security, type safety, and RLS compliance over style preferences. 