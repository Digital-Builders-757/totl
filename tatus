[1mdiff --git a/app/auth/callback/page.tsx b/app/auth/callback/page.tsx[m
[1mindex 28a562f..160c43c 100644[m
[1m--- a/app/auth/callback/page.tsx[m
[1m+++ b/app/auth/callback/page.tsx[m
[36m@@ -1,4 +1,4 @@[m
[31m-ï»¿import { XCircle, CheckCircle2 } from "lucide-react";[m
[32m+[m[32mï»¿import { XCircle } from "lucide-react";[m
 import { redirect } from "next/navigation";[m
 import { Button } from "@/components/ui/button";[m
 import {[m
[36m@@ -199,7 +199,7 @@[m [mexport default async function AuthCallbackPage({[m
             .update({ email_verified: isEmailVerified })[m
             .eq("id", user.id);[m
 [m
[31m-          // Show success confirmation page before redirecting[m
[32m+[m[32m          // Use server-side redirect instead of client-side link to ensure session cookies are set[m
           // Default to Talent Dashboard for new users (MVP: all signups are talent)[m
           // Preserve returnUrl if provided[m
           const baseRedirectUrl = newProfile?.role === "admin"[m
[36m@@ -211,35 +211,8 @@[m [mexport default async function AuthCallbackPage({[m
             ? `${baseRedirectUrl}&returnUrl=${encodeURIComponent(returnUrl)}`[m
             : baseRedirectUrl;[m
           [m
[31m-          // Show success page with auto-redirect[m
[31m-          return ([m
[31m-            <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">[m
[31m-              <Card className="w-full max-w-md">[m
[31m-                <CardHeader>[m
[31m-                  <CardTitle className="text-center">Email Verified Successfully!</CardTitle>[m
[31m-                  <CardDescription className="text-center">[m
[31m-                    Your email has been verified[m
[31m-                  </CardDescription>[m
[31m-                </CardHeader>[m
[31m-                <CardContent className="flex flex-col items-center justify-center py-8">[m
[31m-                  <div className="flex flex-col items-center">[m
[31m-                    <div className="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mb-4">[m
[31m-                      <CheckCircle2 className="h-8 w-8 text-green-600" />[m
[31m-                    </div>[m
[31m-                    <h3 className="text-xl font-medium text-green-800 mb-2">Verification Successful</h3>[m
[31m-                    <p className="text-gray-600 text-center mb-4">[m
[31m-                      Your email address has been verified. You can now access all features of your account.[m
[31m-                    </p>[m
[31m-                  </div>[m
[31m-                </CardContent>[m
[31m-                <CardFooter className="flex justify-center">[m
[31m-                  <Button asChild>[m
[31m-                    <a href={redirectUrl}>Continue to Dashboard</a>[m
[31m-                  </Button>[m
[31m-                </CardFooter>[m
[31m-              </Card>[m
[31m-            </div>[m
[31m-          );[m
[32m+[m[32m          // Use Next.js redirect() to ensure session cookies are properly set before navigation[m
[32m+[m[32m          redirect(redirectUrl);[m
         }[m
 [m
         // If profile exists but display_name is missing/empty, update it[m
[36m@@ -278,7 +251,7 @@[m [mexport default async function AuthCallbackPage({[m
           }[m
         }[m
 [m
[31m-        // Show success confirmation page before redirecting[m
[32m+[m[32m        // Use server-side redirect instead of client-side link to ensure session cookies are set[m
         // Default to Talent Dashboard for new users (MVP: all signups are talent)[m
         // Preserve returnUrl if provided[m
         const baseRedirectUrl = profile?.role === "admin"[m
[36m@@ -290,40 +263,28 @@[m [mexport default async function AuthCallbackPage({[m
           ? `${baseRedirectUrl}&returnUrl=${encodeURIComponent(returnUrl)}`[m
           : baseRedirectUrl;[m
         [m
[31m-        // Show success page with auto-redirect[m
[31m-        return ([m
[31m-          <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">[m
[31m-            <Card className="w-full max-w-md">[m
[31m-              <CardHeader>[m
[31m-                <CardTitle className="text-center">Email Verified Successfully!</CardTitle>[m
[31m-                <CardDescription className="text-center">[m
[31m-                  Your email has been verified[m
[31m-                </CardDescription>[m
[31m-              </CardHeader>[m
[31m-              <CardContent className="flex flex-col items-center justify-center py-8">[m
[31m-                <div className="flex flex-col items-center">[m
[31m-                  <div className="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mb-4">[m
[31m-                    <CheckCircle2 className="h-8 w-8 text-green-600" />[m
[31m-                  </div>[m
[31m-                  <h3 className="text-xl font-medium text-green-800 mb-2">Verification Successful</h3>[m
[31m-                  <p className="text-gray-600 text-center mb-4">[m
[31m-                    Your email address has been verified. You can now access all features of your account.[m
[31m-                  </p>[m
[31m-                </div>[m
[31m-              </CardContent>[m
[31m-              <CardFooter className="flex justify-center">[m
[31m-                <Button asChild>[m
[31m-                  <a href={redirectUrl}>Continue to Dashboard</a>[m
[31m-                </Button>[m
[31m-              </CardFooter>[m
[31m-            </Card>[m
[31m-          </div>[m
[31m-        );[m
[32m+[m[32m        // Use Next.js redirect() to ensure session cookies are properly set before navigation[m
[32m+[m[32m        redirect(redirectUrl);[m
       }[m
 [m
       // Fallback redirect[m
       redirect("/dashboard");[m
     } catch (error) {[m
[32m+[m[32m      // CRITICAL: Next.js redirect() throws a special error to interrupt execution[m
[32m+[m[32m      // We must re-throw redirect errors so they work correctly[m
[32m+[m[32m      // Check if this is a redirect error by checking for NEXT_REDIRECT digest[m
[32m+[m[32m      if ([m
[32m+[m[32m        error &&[m
[32m+[m[32m        typeof error === "object" &&[m
[32m+[m[32m        "digest" in error &&[m
[32m+[m[32m        typeof error.digest === "string" &&[m
[32m+[m[32m        error.digest.startsWith("NEXT_REDIRECT")[m
[32m+[m[32m      ) {[m
[32m+[m[32m        // Re-throw redirect errors so Next.js can handle them properly[m
[32m+[m[32m        throw error;[m
[32m+[m[32m      }[m
[32m+[m[41m      [m
[32m+[m[32m      // Only log and show error UI for actual errors, not redirects[m
       console.error("Unexpected error:", error);[m
       return ([m
         <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">[m
[1mdiff --git a/app/talent/dashboard/page.tsx b/app/talent/dashboard/page.tsx[m
[1mindex f231211..d620421 100644[m
[1m--- a/app/talent/dashboard/page.tsx[m
[1m+++ b/app/talent/dashboard/page.tsx[m
[36m@@ -106,6 +106,9 @@[m [mfunction TalentDashboardContent() {[m
   const loadingTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null); // Track loading timeout[m
   const fetchedProfileRef = useRef<boolean>(false); // Track if we've fetched data when profile was available[m
   const currentFetchTimeoutIdRef = useRef<ReturnType<typeof setTimeout> | null>(null); // Track which timeout belongs to current fetch operation[m
[32m+[m[32m  const hasHandledVerificationRef = useRef<boolean>(false); // Track if we've already handled the verification parameter to prevent infinite loops[m
[32m+[m[32m  const isInVerificationGracePeriodRef = useRef<boolean>(false); // Track grace period state independently of URL[m
[32m+[m[32m  const urlCleanupTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null); // Track the cleanup timeout[m
 [m
   // Check if Supabase is configured[m
   const isSupabaseConfigured =[m
[36m@@ -115,12 +118,133 @@[m [mfunction TalentDashboardContent() {[m
 [m
   const supabase = isSupabaseConfigured ? createSupabaseBrowser() : null;[m
 [m
[31m-  // Redirect unauthenticated users away from dashboard and show clear CTA[m
[32m+[m[32m  // EFFECT A: Verification Flow Manager[m
[32m+[m[32m  // Responsibility: Handle verification flow & URL cleanup[m
[32m+[m[32m  // This effect watches the verified param from URL and manages the grace period[m
   useEffect(() => {[m
[31m-    if (!isLoading && !user) {[m
[32m+[m[32m    const verifiedParam = searchParams.get("verified");[m
[32m+[m[41m    [m
[32m+[m[32m    // Only start the verification flow once per mount[m
[32m+[m[32m    if (verifiedParam !== "true" || hasHandledVerificationRef.current) {[m
[32m+[m[32m      return;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Mark that we've started the verification flow[m
[32m+[m[32m    hasHandledVerificationRef.current = true;[m
[32m+[m[41m    [m
[32m+[m[32m    // Enter grace period immediately (before *anything* else happens)[m
[32m+[m[32m    // This ref persists across re-renders even when URL changes[m
[32m+[m[32m    isInVerificationGracePeriodRef.current = true;[m
[32m+[m[41m    [m
[32m+[m[32m    // Pull in the fresh Supabase session after email verification[m
[32m+[m[32m    router.refresh();[m
[32m+[m[41m    [m
[32m+[m[32m    // Clear any previous timer just in case[m
[32m+[m[32m    if (urlCleanupTimeoutRef.current) {[m
[32m+[m[32m      clearTimeout(urlCleanupTimeoutRef.current);[m
[32m+[m[32m      urlCleanupTimeoutRef.current = null;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Schedule URL cleanup AFTER the 2s grace period[m
[32m+[m[32m    // CRITICAL: Timeout callback does NOT check user state (avoids stale closures)[m
[32m+[m[32m    urlCleanupTimeoutRef.current = setTimeout(() => {[m
[32m+[m[32m      try {[m
[32m+[m[32m        const url = new URL(window.location.href);[m
[32m+[m[32m        url.searchParams.delete("verified");[m
[32m+[m[32m        // Use relative path to avoid full-page navigation semantics[m
[32m+[m[32m        router.replace(`${url.pathname}${url.search}`);[m
[32m+[m[32m      } finally {[m
[32m+[m[32m        // Exit grace period *after* the URL is clean[m
[32m+[m[32m        // Effect B will handle redirects once grace period is false[m
[32m+[m[32m        isInVerificationGracePeriodRef.current = false;[m
[32m+[m[32m        urlCleanupTimeoutRef.current = null;[m
[32m+[m[32m      }[m
[32m+[m[32m    }, 2000);[m
[32m+[m[41m    [m
[32m+[m[32m    // Cleanup function runs on:[m
[32m+[m[32m    // 1. Effect re-run (when dependencies change)[m
[32m+[m[32m    // 2. Component unmount[m
[32m+[m[32m    //[m
[32m+[m[32m    // CRITICAL: We need to handle both cases correctly:[m
[32m+[m[32m    // - On re-run due to searchParams change: Don't clear timeout if verification handled (prevents race condition)[m
[32m+[m[32m    // - On unmount: Always clear timeout (prevents memory leak and operations on unmounted component)[m
[32m+[m[32m    // - If verified parameter is removed: Reset grace period to prevent it from being stuck[m
[32m+[m[32m    //[m
[32m+[m[32m    // Strategy: Always clear the timeout to prevent memory leaks and operations on unmounted components.[m
[32m+[m[32m    // Additionally, if the verified parameter is no longer present, reset the grace period ref to prevent[m
[32m+[m[32m    // it from being stuck in the true state, which would block Effect B from redirecting users.[m
[32m+[m[32m    return () => {[m
[32m+[m[32m      // Always clear timeout to prevent memory leaks and operations on unmounted component[m
[32m+[m[32m      if (urlCleanupTimeoutRef.current) {[m
[32m+[m[32m        clearTimeout(urlCleanupTimeoutRef.current);[m
[32m+[m[32m        urlCleanupTimeoutRef.current = null;[m
[32m+[m[32m      }[m
[32m+[m[41m      [m
[32m+[m[32m      // CRITICAL: Read current URL state directly from window.location to avoid stale closure issues.[m
[32m+[m[32m      // The searchParams hook value may be captured in the closure, but window.location always reflects[m
[32m+[m[32m      // the current URL state. This ensures we correctly detect if the verified parameter was removed.[m
[32m+[m[32m      try {[m
[32m+[m[32m        const currentUrl = new URL(window.location.href);[m
[32m+[m[32m        const currentVerifiedParam = currentUrl.searchParams.get("verified");[m
[32m+[m[41m        [m
[32m+[m[32m        // CRITICAL: Only reset grace period if verified parameter is actually removed from URL.[m
[32m+[m[32m        // Do NOT reset just because timeout was cleared - clearing timeout is just cleanup,[m
[32m+[m[32m        // not an indication that verification flow is complete.[m
[32m+[m[32m        //[m
[32m+[m[32m        // The grace period should remain active until:[m
[32m+[m[32m        // 1. The timeout callback completes and removes the parameter (handled in timeout callback's finally block), OR[m
[32m+[m[32m        // 2. The parameter is removed by some other means (detected here)[m
[32m+[m[32m        //[m
[32m+[m[32m        // Resetting grace period prematurely when verified parameter is still present would allow[m
[32m+[m[32m        // Effect B to redirect before router.refresh() completes, defeating the grace period's purpose.[m
[32m+[m[32m        if (hasHandledVerificationRef.current && currentVerifiedParam !== "true") {[m
[32m+[m[32m          // Verified parameter was removed - reset grace period so Effect B can function normally[m
[32m+[m[32m          isInVerificationGracePeriodRef.current = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        // Note: If verified parameter is still present, keep grace period active even if timeout was cleared.[m
[32m+[m[32m        // This ensures the grace period protects the verification flow until the parameter is actually removed.[m
[32m+[m[32m      } catch (error) {[m
[32m+[m[32m        // If URL parsing fails (shouldn't happen), don't reset grace period as safety measure[m
[32m+[m[32m        // Better to keep grace period active than risk premature redirects[m
[32m+[m[32m        console.error("Error reading URL in cleanup:", error);[m
[32m+[m[32m      }[m
[32m+[m[41m      [m
[32m+[m[32m      // Note: We intentionally don't reset hasHandledVerificationRef here[m
[32m+[m[32m      // because cleanup runs on every effect re-run (when deps change), not just unmount.[m
[32m+[m[32m      // Resetting it would cause the effect to re-trigger when searchParams object identity changes.[m
[32m+[m[32m      //[m
[32m+[m[32m      // Race condition prevention: The effect checks `hasHandledVerificationRef.current` at the start (line 128)[m
[32m+[m[32m      // and returns early if verification has already been handled, preventing re-scheduling of the timeout.[m
[32m+[m[32m      // If verification is still being handled and this is a re-run, the effect will re-enter and restore[m
[32m+[m[32m      // the grace period state, so resetting it here is safe.[m
[32m+[m[32m    };[m
[32m+[m[32m  }, [searchParams, router]);[m
[32m+[m
[32m+[m[32m  // EFFECT B: Redirect Guardrail[m
[32m+[m[32m  // Responsibility: Handle redirect logic based on auth state[m
[32m+[m[32m  // This effect NEVER reads verified from URL - only checks the grace period ref[m
[32m+[m[32m  useEffect(() => {[m
[32m+[m[32m    // Don't do anything while auth is still resolving[m
[32m+[m[32m    if (isLoading) {[m
[32m+[m[32m      return;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // ðŸš« During verification grace period, never redirect[m
[32m+[m[32m    // Effect A's timeout will exit grace period after URL cleanup completes[m
[32m+[m[32m    // This prevents premature redirects before router.refresh() completes[m
[32m+[m[32m    if (isInVerificationGracePeriodRef.current) {[m
[32m+[m[32m      return;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // --- Normal redirect logic after grace period: ---[m
[32m+[m[32m    // Unauthenticated â†’ login[m
[32m+[m[32m    if (!user) {[m
       router.replace(`/login?returnUrl=${encodeURIComponent("/talent/dashboard")}`);[m
[32m+[m[32m      return;[m
     }[m
[31m-  }, [isLoading, user, router]);[m
[32m+[m[41m    [m
[32m+[m[32m    // Other redirect conditions can be added here if needed[m
[32m+[m[32m  }, [user, isLoading, router]);[m
 [m
   // Calculate dashboard stats from real data[m
   const dashboardStats = {[m
[36m@@ -378,6 +502,7 @@[m [mfunction TalentDashboardContent() {[m
     }[m
   }, [searchParams, toast]);[m
 [m
[32m+[m
   const handleViewDetails = (application: TalentApplication) => {[m
     setSelectedTalentApplication(application);[m
     setIsModalOpen(true);[m
[36m@@ -416,6 +541,9 @@[m [mfunction TalentDashboardContent() {[m
       if (loadingTimeoutRef.current) {[m
         clearTimeout(loadingTimeoutRef.current);[m
       }[m
[32m+[m[32m      if (urlCleanupTimeoutRef.current) {[m
[32m+[m[32m        clearTimeout(urlCleanupTimeoutRef.current);[m
[32m+[m[32m      }[m
     };[m
   }, []);[m
 [m
